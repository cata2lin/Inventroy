# routes/sync_control.py

from fastapi import APIRouter, Depends, BackgroundTasks, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from pydantic import BaseModel
from database import get_db, SessionLocal
from services import sync_service, sync_tracker
from crud import store as crud_store

router = APIRouter(
    prefix="/api/sync-control",
    tags=["Sync Control"],
    responses={404: {"description": "Not found"}},
)

class SyncRequest(BaseModel):
    store_id: Optional[int] = None
    start_date: Optional[str] = None
    end_date: Optional[str] = None

@router.post("/orders", status_code=202)
def trigger_order_sync(request: SyncRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    """
    Triggers a background sync of orders. Can be for all stores, a single store, or a date range.
    """
    task_ids = []
    if request.store_id:
        store = crud_store.get_store(db, store_id=request.store_id)
        if not store:
            raise HTTPException(status_code=404, detail="Store not found")
        stores_to_sync = [store]
    else:
        stores_to_sync = crud_store.get_stores(db)

    for store in stores_to_sync:
        task_id = sync_tracker.create_task(f"Orders for {store.name}")
        task_ids.append(task_id)
        # --- FIX: Pass primitive types, not the 'store' object ---
        background_tasks.add_task(
            sync_service.run_sync_in_background,
            target_function=sync_service.run_full_order_sync,
            db_session_factory=SessionLocal,
            store_id=store.id,
            task_id=task_id,
            start_date=request.start_date,
            end_date=request.end_date
        )
    return {"message": "Order synchronization started.", "task_ids": task_ids}

@router.post("/products", status_code=202)
def trigger_product_sync(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    """Triggers a background sync of all products for ALL stores."""
    stores = crud_store.get_stores(db)
    task_ids = []
    for store in stores:
        task_id = sync_tracker.create_task(f"Products for {store.name}")
        task_ids.append(task_id)
        # --- FIX: Pass primitive types, not the 'store' object ---
        background_tasks.add_task(
            sync_service.run_sync_in_background,
            target_function=sync_service.run_full_product_sync,
            db_session_factory=SessionLocal,
            store_id=store.id,
            task_id=task_id
        )
    return {"message": "Full product synchronization started for all stores.", "task_ids": task_ids}

@router.get("/status")
def get_all_tasks_status():
    return sync_tracker.get_all_tasks()